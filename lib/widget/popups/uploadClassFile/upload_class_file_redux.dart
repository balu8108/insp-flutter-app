// This file is "main.dart"
import 'package:dio/dio.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:insp/data/hardcoded/secret_key.dart';
import 'package:insp/utils/userDetail/getUserDetail.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';
import 'package:toastification/toastification.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'upload_class_file_redux.freezed.dart';

@freezed
class UploadClassFileAppState with _$UploadClassFileAppState {
  const factory UploadClassFileAppState(
      {required String classtype,
      required String classroomId,
      @Default([]) List<String> pickedFilesName,
      @Default([]) List<PlatformFile> pickedFiles,
      @Default(false) bool isLoading}) = _UploadClassFileAppState;
}

sealed class UploadClassFileAction {}

class UpdateLiveClassPickedFiles extends UploadClassFileAction {
  List<PlatformFile> pickedFiles;
  UpdateLiveClassPickedFiles({required this.pickedFiles});
}

class UpdateLiveClassPickedFilesName extends UploadClassFileAction {
  List<String> pickedFilesName;
  UpdateLiveClassPickedFilesName({required this.pickedFilesName});
}

class UpdateIsLoading extends UploadClassFileAction {
  bool isLoading;
  UpdateIsLoading({required this.isLoading});
}

UploadClassFileAppState _uploadClassFileStateReducer(
    UploadClassFileAppState state, UploadClassFileAction action) {
  switch (action) {
    case UpdateLiveClassPickedFiles():
      return state.copyWith(pickedFiles: action.pickedFiles);
    case UpdateLiveClassPickedFilesName():
      return state.copyWith(pickedFilesName: action.pickedFilesName);
    case UpdateIsLoading():
      return state.copyWith(isLoading: action.isLoading);
    case RemoveLiveClassFile():
      return state.copyWith(
        pickedFilesName: state.pickedFilesName
            .where((name) => name != action.filename)
            .toList(),
        pickedFiles: state.pickedFiles
            .where((file) => file.name != action.filename)
            .toList(),
      );
  }
}

UploadClassFileAppState uploadClassFileStateReducer(
    UploadClassFileAppState state, dynamic action) {
  var upState = _uploadClassFileStateReducer(state, action);
  return upState;
}

class RemoveLiveClassFile extends UploadClassFileAction {
  String filename;
  RemoveLiveClassFile({required this.filename});
}

ThunkAction<UploadClassFileAppState> pickFilesforliveclass(
    BuildContext context) {
  return (Store<UploadClassFileAppState> store) async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        allowMultiple: false,
        type: FileType.custom,
        allowedExtensions: ['pdf'],
      );

      if (result != null) {
        List<PlatformFile> pickedFiles = result.files;
        List<String> pickedFilesName =
            pickedFiles.map((item) => item.name).toList();
        store.dispatch(UpdateLiveClassPickedFiles(pickedFiles: pickedFiles));
        store.dispatch(
            UpdateLiveClassPickedFilesName(pickedFilesName: pickedFilesName));
      } else {
        print('User canceled the picker');
      }
    } catch (e) {
      print('Error picking file: $e');
    }
  };
}

ThunkAction<UploadClassFileAppState> handleUploadFileClass(
    BuildContext context, Function() getAllUpcomingClass) {
  return (Store<UploadClassFileAppState> store) async {
    List<MultipartFile> files = [];

    store.dispatch(UpdateIsLoading(isLoading: true));

    for (PlatformFile file in store.state.pickedFiles) {
      if (kIsWeb) {
        files.add(MultipartFile.fromBytes(file.bytes!, filename: file.name));
      } else {
        files
            .add(await MultipartFile.fromFile(file.path!, filename: file.name));
      }
    }

    FormData formData = FormData.fromMap({
      'files': files,
    });

    final dio = Dio();
    try {
      String userToken = getUserToken(context);
      Response response = await dio.post(
        '$api/schedule-live-class/upload-assignment-to-class/${store.state.classtype}/${store.state.classroomId}',
        data: formData,
        options: Options(
          headers: {
            'Authorization': userToken, // Include the token in the header
            'Content-Type': 'multipart/form-data',
          },
        ),
      );

      if (response.statusCode == 200) {
        store.dispatch(UpdateIsLoading(isLoading: false));
        getAllUpcomingClass();
        Navigator.of(context).pop();
        toastification.show(
          context: context, // optional if you use ToastificationWrapper
          type: ToastificationType.success,
          style: ToastificationStyle.fillColored,
          autoCloseDuration: const Duration(seconds: 3),
          title: const Text('File upload successfully'),
          alignment: Alignment.topRight,
        );
      } else {
        store.dispatch(UpdateIsLoading(isLoading: false));
        Navigator.of(context).pop();
        toastification.show(
          context: context, // optional if you use ToastificationWrapper
          type: ToastificationType.warning,
          style: ToastificationStyle.fillColored,
          autoCloseDuration: const Duration(seconds: 3),
          title: const Text('Please try again'),
          alignment: Alignment.topRight,
        );
      }
    } on DioException catch (e) {
      store.dispatch(UpdateIsLoading(isLoading: false));
      // Handle Dio-specific errors
      String errorMessage;
      if (e.response != null) {
        final errorData = e.response?.data;
        errorMessage = errorData['error'] ?? 'An unexpected error occurred';
      } else {
        errorMessage = 'Network error or server not reachable';
      }
      toastification.show(
        context: context, // optional if you use ToastificationWrapper
        type: ToastificationType.error,
        style: ToastificationStyle.fillColored,
        autoCloseDuration: const Duration(seconds: 3),
        title: Text(errorMessage),
        alignment: Alignment.topRight,
      );
    } catch (e) {
      store.dispatch(UpdateIsLoading(isLoading: false));
      toastification.show(
        context: context, // optional if you use ToastificationWrapper
        type: ToastificationType.error,
        style: ToastificationStyle.fillColored,
        autoCloseDuration: const Duration(seconds: 3),
        title: const Text('ggh'),
        alignment: Alignment.topRight,
      );
    }
  };
}
