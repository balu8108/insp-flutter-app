// This file is "main.dart"
import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:inspflutterfrontend/apiservices/models/mycourses/all_lectures_for_course_response_model.dart';
import 'package:inspflutterfrontend/data/hardcoded/secret_key.dart';
import 'package:inspflutterfrontend/data/hardcoded/topic_list.dart';
import 'package:inspflutterfrontend/utils/userDetail/getUserDetail.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';
import 'package:toastification/toastification.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'add_assignment_redux.freezed.dart';

@freezed
class AddAssignmentAppState with _$AddAssignmentAppState {
  const factory AddAssignmentAppState(
      {required int assignmentId,
      required bool isEditScreen,
      required String? selectedSubject,
      @Default('') String? selectedSubjectError,
      required String? selectedTopic,
      @Default('') String? selectedTopicError,
      required String? description,
      @Default('') String? descriptionError,
      required List<LiveClassRoomFile> previousFiles,
      @Default([]) List<int> deletedFileId,
      @Default([]) List<String> pickedFilesName,
      @Default([]) List<PlatformFile> pickedFiles,
      @Default(false) bool isAssignmentLoading}) = _AddAssignmentAppState;
}

sealed class AddAssignmentAction {}

class UpdateSelectedSubject extends AddAssignmentAction {
  String? selectedSubject;
  UpdateSelectedSubject({required this.selectedSubject});
}

class UpdateSelectedSubjectError extends AddAssignmentAction {
  String? selectedSubjectError;
  UpdateSelectedSubjectError({required this.selectedSubjectError});
}

class UpdateSelectedTopic extends AddAssignmentAction {
  String? selectedTopic;
  UpdateSelectedTopic({required this.selectedTopic});
}

class UpdateSelectedTopicError extends AddAssignmentAction {
  String? selectedTopicError;
  UpdateSelectedTopicError({required this.selectedTopicError});
}

class UpdateDescription extends AddAssignmentAction {
  String? description;
  UpdateDescription({required this.description});
}

class UpdateDescriptionError extends AddAssignmentAction {
  String descriptionError;
  UpdateDescriptionError({required this.descriptionError});
}

class UpdatePickedFiles extends AddAssignmentAction {
  List<PlatformFile> pickedFiles;
  UpdatePickedFiles({required this.pickedFiles});
}

class UpdatePickedFilesName extends AddAssignmentAction {
  List<String> pickedFilesName;
  UpdatePickedFilesName({required this.pickedFilesName});
}

class UpdateIsAssignmentLoading extends AddAssignmentAction {
  bool isAssignmentLoading;
  UpdateIsAssignmentLoading({required this.isAssignmentLoading});
}

class RemoveFileAction extends AddAssignmentAction {
  String filename;
  RemoveFileAction({required this.filename});
}

class RemovePreviousAssignmentFile extends AddAssignmentAction {
  int id;
  RemovePreviousAssignmentFile({required this.id});
}

AddAssignmentAppState _addAssignmentStateReducer(
    AddAssignmentAppState state, AddAssignmentAction action) {
  switch (action) {
    case UpdateSelectedSubject():
      return state.copyWith(
          selectedSubject: action.selectedSubject, selectedSubjectError: '');
    case UpdateSelectedSubjectError():
      return state.copyWith(selectedSubjectError: action.selectedSubjectError);
    case UpdateSelectedTopic():
      return state.copyWith(
          selectedTopic: action.selectedTopic, selectedTopicError: '');
    case UpdateSelectedTopicError():
      return state.copyWith(selectedTopicError: action.selectedTopicError);
    case UpdateDescription():
      return state.copyWith(
          description: action.description, descriptionError: '');
    case UpdateDescriptionError():
      return state.copyWith(descriptionError: action.descriptionError);
    case UpdatePickedFiles():
      return state.copyWith(pickedFiles: action.pickedFiles);
    case UpdatePickedFilesName():
      return state.copyWith(pickedFilesName: action.pickedFilesName);
    case UpdateIsAssignmentLoading():
      return state.copyWith(isAssignmentLoading: action.isAssignmentLoading);
    case RemovePreviousAssignmentFile():
      return state.copyWith(
          deletedFileId: [...state.deletedFileId, action.id],
          previousFiles: state.previousFiles
              .where((file) => file.id != action.id)
              .toList());
    case RemoveFileAction():
      return state.copyWith(
        pickedFilesName: state.pickedFilesName
            .where((name) => name != action.filename)
            .toList(),
        pickedFiles: state.pickedFiles
            .where((file) => file.name != action.filename)
            .toList(),
      );
  }
}

AddAssignmentAppState addAssignmentStateReducer(
    AddAssignmentAppState state, dynamic action) {
  var upState = _addAssignmentStateReducer(state, action);
  return upState;
}

ThunkAction<AddAssignmentAppState> pickFiles(BuildContext context) {
  return (Store<AddAssignmentAppState> store) async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        allowMultiple: true,
        type: FileType.custom,
        allowedExtensions: ['pdf'],
      );

      if (result != null) {
        List<PlatformFile> pickedFiles = result.files;
        List<String> pickedFilesName =
            pickedFiles.map((item) => item.name).toList();
        store.dispatch(UpdatePickedFiles(pickedFiles: pickedFiles));
        store.dispatch(UpdatePickedFilesName(pickedFilesName: pickedFilesName));
      } else {
        print('User canceled the picker');
      }
    } catch (e) {
      print('Error picking file: $e');
    }
  };
}

ThunkAction<AddAssignmentAppState> handleCreate(
    BuildContext context, Function() getAssignment) {
  return (Store<AddAssignmentAppState> store) async {
    List<MultipartFile> files = [];

    store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: true));

    if (store.state.selectedSubject == null ||
        store.state.selectedSubject!.isEmpty) {
      store.dispatch(UpdateSelectedSubjectError(
          selectedSubjectError: 'Please select a subject'));
      return;
    }
    if (store.state.selectedTopic == null ||
        store.state.selectedTopic!.isEmpty) {
      store.dispatch(UpdateSelectedTopicError(
          selectedTopicError: 'Please select a topic'));
      return;
    }
    if (store.state.description == null || store.state.description!.isEmpty) {
      store.dispatch(UpdateDescriptionError(
          descriptionError: 'Please enter an description'));
      return;
    }

    for (PlatformFile file in store.state.pickedFiles) {
      if (kIsWeb) {
        files.add(MultipartFile.fromBytes(file.bytes!, filename: file.name));
      } else {
        files
            .add(await MultipartFile.fromFile(file.path!, filename: file.name));
      }
    }
    Map<String, dynamic> jsonObject = {
      'value': subjectList
          .firstWhere((item) => item.label == store.state.selectedSubject)
          .value,
      'label': store.state.selectedSubject,
    };

    Map<String, dynamic> jsonObjectTwo = {
      'value': topicList
          .firstWhere((item) => item.label == store.state.selectedTopic)
          .value,
      'label': store.state.selectedTopic,
    };

    FormData formData = FormData.fromMap({
      'subject': jsonEncode(jsonObject),
      'topic': jsonEncode(jsonObjectTwo),
      'description': store.state.description,
      'files': files,
    });

    final dio = Dio();
    try {
      String userToken = await getUserToken();
      Response response = await dio.post(
        '${api}/assignment/upload-assignments',
        data: formData,
        options: Options(
          headers: {
            'Authorization': userToken, // Include the token in the header
            'Content-Type': 'multipart/form-data',
          },
        ),
      );

      if (response.statusCode == 201) {
        store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: false));
        getAssignment();
        Navigator.of(context).pop();
        toastification.show(
          context: context, // optional if you use ToastificationWrapper
          type: ToastificationType.success,
          style: ToastificationStyle.fillColored,
          autoCloseDuration: const Duration(seconds: 3),
          title: const Text('Assignment created successfully'),
          alignment: Alignment.topRight,
        );
      } else {
        store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: false));
        Navigator.of(context).pop();
        toastification.show(
          context: context, // optional if you use ToastificationWrapper
          type: ToastificationType.warning,
          style: ToastificationStyle.fillColored,
          autoCloseDuration: const Duration(seconds: 3),
          title: const Text('Failed to upload files'),
          alignment: Alignment.topRight,
        );
      }
    } catch (e) {
      store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: false));
      toastification.show(
        context: context, // optional if you use ToastificationWrapper
        type: ToastificationType.error,
        style: ToastificationStyle.fillColored,
        autoCloseDuration: const Duration(seconds: 3),
        title: const Text('Some issue, please try again'),
        alignment: Alignment.topRight,
      );
    }
  };
}

ThunkAction<AddAssignmentAppState> handleUpdate(
    BuildContext context, Function() fetchAssignmentAfterUpdateorDelete) {
  return (Store<AddAssignmentAppState> store) async {
    List<MultipartFile> files = [];

    store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: true));

    if (store.state.selectedSubject == null ||
        store.state.selectedSubject!.isEmpty) {
      store.dispatch(UpdateSelectedSubjectError(
          selectedSubjectError: 'Please select a subject'));
      return;
    }
    if (store.state.selectedTopic == null ||
        store.state.selectedTopic!.isEmpty) {
      store.dispatch(UpdateSelectedTopicError(
          selectedTopicError: 'Please select a topic'));
      return;
    }
    if (store.state.description == null || store.state.description!.isEmpty) {
      store.dispatch(UpdateDescriptionError(
          descriptionError: 'Please enter an description'));
      return;
    }

    for (PlatformFile file in store.state.pickedFiles) {
      if (kIsWeb) {
        files.add(MultipartFile.fromBytes(file.bytes!, filename: file.name));
      } else {
        files
            .add(await MultipartFile.fromFile(file.path!, filename: file.name));
      }
    }

    Map<String, dynamic> jsonObject = {
      'value': subjectList
          .firstWhere((item) => item.label == store.state.selectedSubject)
          .value,
      'label': store.state.selectedSubject,
    };

    Map<String, dynamic> jsonObjectTwo = {
      'value': topicList
          .firstWhere((item) => item.label == store.state.selectedTopic)
          .value,
      'label': store.state.selectedTopic,
    };

    FormData formData = FormData.fromMap({
      'assignmentId': store.state.assignmentId,
      'subject': jsonEncode(jsonObject),
      'topic': jsonEncode(jsonObjectTwo),
      'description': store.state.description,
      'files': files,
      if (store.state.deletedFileId.isNotEmpty)
        'deletedFileIds': jsonEncode(store.state.deletedFileId),
    });

    final dio = Dio();
    try {
      String userToken = await getUserToken();
      Response response = await dio.post(
        '${api}/assignment/update-assignments',
        data: formData,
        options: Options(
          headers: {
            'Authorization': userToken, // Include the token in the header
            'Content-Type': 'multipart/form-data',
          },
        ),
      );

      if (response.statusCode == 200) {
        store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: false));
        fetchAssignmentAfterUpdateorDelete();
        Navigator.of(context).pop();
        toastification.show(
          context: context, // optional if you use ToastificationWrapper
          type: ToastificationType.success,
          style: ToastificationStyle.fillColored,
          autoCloseDuration: const Duration(seconds: 3),
          title: const Text('Assignment update successfully'),
          alignment: Alignment.topRight,
        );
      } else {
        store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: false));
        Navigator.of(context).pop();
        toastification.show(
          context: context, // optional if you use ToastificationWrapper
          type: ToastificationType.warning,
          style: ToastificationStyle.fillColored,
          autoCloseDuration: const Duration(seconds: 3),
          title: const Text('Failed to update assignment'),
          alignment: Alignment.topRight,
        );
      }
    } catch (e) {
      store.dispatch(UpdateIsAssignmentLoading(isAssignmentLoading: false));
      toastification.show(
        context: context, // optional if you use ToastificationWrapper
        type: ToastificationType.error,
        style: ToastificationStyle.fillColored,
        autoCloseDuration: const Duration(seconds: 3),
        title: const Text('Some issue, please try again'),
        alignment: Alignment.topRight,
      );
    }
  };
}
