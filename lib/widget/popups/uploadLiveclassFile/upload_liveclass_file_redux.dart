// This file is "main.dart"
import 'dart:io';

import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:inspflutterfrontend/redux/AppState.dart';
import 'package:inspflutterfrontend/socket/mainsocket.dart';
import 'package:mime/mime.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'upload_liveclass_file_redux.freezed.dart';

@freezed
class UploadLiveclassFileAppState with _$UploadLiveclassFileAppState {
  const factory UploadLiveclassFileAppState(
      {@Default('') String pickedFilesName,
      @Default([]) List<PlatformFile> pickedFiles,
      @Default(false) bool isPopupOpen}) = _UploadLiveclassFileAppState;
}

sealed class UploadLiveclassFileAction {}

class UpdateLiveClassPickedFiles extends UploadLiveclassFileAction {
  List<PlatformFile> pickedFiles;
  UpdateLiveClassPickedFiles({required this.pickedFiles});
}

class UpdateLiveClassPickedFilesName extends UploadLiveclassFileAction {
  String pickedFilesName;
  UpdateLiveClassPickedFilesName({required this.pickedFilesName});
}

UploadLiveclassFileAppState uploadLiveclassFileStateReducer(
    UploadLiveclassFileAppState state, dynamic action) {
  if (action is UpdateLiveClassPickedFiles) {
    return state.copyWith(pickedFiles: action.pickedFiles);
  } else if (action is UpdateLiveClassPickedFilesName) {
    return state.copyWith(pickedFilesName: action.pickedFilesName);
  }
  return state;
}

ThunkAction<AppState> pickFilesforliveclass(BuildContext context) {
  return (Store<AppState> store) async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        allowMultiple: false,
        type: FileType.custom,
        allowedExtensions: ['pdf'],
      );

      if (result != null) {
        List<PlatformFile> pickedFiles = result.files;
        List<String> pickedFilesName =
            pickedFiles.map((item) => item.name).toList();
        store.dispatch(UpdateLiveClassPickedFiles(pickedFiles: pickedFiles));
        store.dispatch(UpdateLiveClassPickedFilesName(
            pickedFilesName: pickedFilesName[0]));
      } else {
        print('User canceled the picker');
      }
    } catch (e) {
      print('Error picking file: $e');
    }
  };
}

ThunkAction<AppState> uploadFilesToServer(
    BuildContext context, List<PlatformFile> pickedFiles, String roomId) {
  return (Store<AppState> store) async {
    try {
      Map<String, dynamic> fileObj = {
        'roomType': 'active',
        'roomId': roomId,
        'files': [],
      };
      // Loop through picked files and create the necessary objects
      for (PlatformFile file in pickedFiles) {
        Uint8List? fileBytes;

        // Check if the file is web-based or not
        if (kIsWeb) {
          fileBytes = file.bytes; // Web uses bytes directly
        } else {
          // For non-web platforms, load the file bytes from the file path if bytes are null
          fileBytes = file.bytes ?? await File(file.path!).readAsBytes();
        }

        Map<String, dynamic> fileData = {
          'name': file.name,
          'mimetype': lookupMimeType(file.name),
          'data': fileBytes, // Using the bytes from PlatformFile or file path
        };
        fileObj['files'].add(fileData);
      }

      sendFileHandler(store, fileObj);
      store.dispatch(UpdateLiveClassPickedFiles(pickedFiles: []));
      store.dispatch(UpdateLiveClassPickedFilesName(pickedFilesName: ''));
      Navigator.of(context).pop();
    } catch (e) {
      print('Error picking file: $e');
    }
  };
}
