// This file is "main.dart"
import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:fluttertoast/fluttertoast.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:inspflutterfrontend/apiservices/models/library/all_topic_for_chapter_request_model.dart';
import 'package:inspflutterfrontend/apiservices/models/mycourses/get_lecture_no_request_model.dart';
import 'package:inspflutterfrontend/apiservices/remote_data_source.dart';
import 'package:inspflutterfrontend/data/hardcoded/topic_list.dart';
import 'package:inspflutterfrontend/utils/getUserDetail.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'schedule_liveclass_redux.freezed.dart';

@freezed
class ScheduleLiveclassAppState with _$ScheduleLiveclassAppState {
  const factory ScheduleLiveclassAppState(
      [@Default('') String? selectedSubject,
      @Default('') String? selectedSubjectError,
      @Default('') String? selectedDate,
      @Default('') String? selectedDateError,
      @Default('') String? selectedStartTime,
      @Default('') String? selectedStartTimeError,
      @Default('') String? selectedEndTime,
      @Default('') String? selectedEndTimeError,
      @Default('') String? selectedChapter,
      @Default('') String? selectedChapterError,
      @Default('') String? selectedTopic,
      @Default('') String? selectedTopicError,
      @Default('') String? selectedClassLevel,
      @Default('') String? selectedClassLevelError,
      @Default('') String? selectedCourseType,
      @Default('') String? selectedCourseTypeError,
      @Default('') String? lectureNo,
      @Default('') String? agenda,
      @Default('') String? agendaError,
      @Default('') String? description,
      @Default('') String? descriptionError,
      @Default([]) List<ChapterTopicModel> allTopics,
      @Default([]) List<String> pickedFilesName,
      @Default([]) List<PlatformFile> pickedFiles,
      @Default(false) bool? isStudentMuted]) = _ScheduleLiveclassAppState;
}

sealed class ScheduleLiveclassAction {}

// selectedSubject action
class UpdateLiveClassSelectedSubject extends ScheduleLiveclassAction {
  String? selectedSubject;
  UpdateLiveClassSelectedSubject({required this.selectedSubject});
}

class UpdateLiveClassSelectedSubjectError extends ScheduleLiveclassAction {
  String? selectedSubjectError;
  UpdateLiveClassSelectedSubjectError({required this.selectedSubjectError});
}

class UpdateAllTopics extends ScheduleLiveclassAction {
  List<ChapterTopicModel> allTopics;
  UpdateAllTopics({required this.allTopics});
}

// topic action
class UpdateSelectedTopic extends ScheduleLiveclassAction {
  String? selectedTopic;
  UpdateSelectedTopic({required this.selectedTopic});
}

class UpdateSelectedTopicError extends ScheduleLiveclassAction {
  String selectedTopicsError;
  UpdateSelectedTopicError({required this.selectedTopicsError});
}

// selectedDate action
class UpdateLiveClassSelectedDate extends ScheduleLiveclassAction {
  String? selectedDate;
  UpdateLiveClassSelectedDate({required this.selectedDate});
}

class UpdateLiveClassSelectedDateError extends ScheduleLiveclassAction {
  String? selectedDateError;
  UpdateLiveClassSelectedDateError({required this.selectedDateError});
}

// selectedstarttime action
class UpdateLiveClassSelectedStartTime extends ScheduleLiveclassAction {
  String? selectedStartTime;
  UpdateLiveClassSelectedStartTime({required this.selectedStartTime});
}

class UpdateLiveClassSelectedStartTimeError extends ScheduleLiveclassAction {
  String? selectedStartTimeError;
  UpdateLiveClassSelectedStartTimeError({required this.selectedStartTimeError});
}

// selectedendtime action
class UpdateLiveClassSelectedEndTime extends ScheduleLiveclassAction {
  String? selectedEndTime;
  UpdateLiveClassSelectedEndTime({required this.selectedEndTime});
}

class UpdateLiveClassSelectedEndTimeError extends ScheduleLiveclassAction {
  String? selectedEndTimeError;
  UpdateLiveClassSelectedEndTimeError({required this.selectedEndTimeError});
}

// chapter action
class UpdateLiveClassSelectedChapter extends ScheduleLiveclassAction {
  String? selectedChapter;
  UpdateLiveClassSelectedChapter({required this.selectedChapter});
}

class UpdateLiveClassSelectedChapterError extends ScheduleLiveclassAction {
  String? selectedChapterError;
  UpdateLiveClassSelectedChapterError({required this.selectedChapterError});
}

// classlevel action
class UpdateLiveClassSelectedClassLevel extends ScheduleLiveclassAction {
  String? selectedClassLevel;
  UpdateLiveClassSelectedClassLevel({required this.selectedClassLevel});
}

class UpdateLiveClassSelectedClassLevelError extends ScheduleLiveclassAction {
  String? selectedClassLevelError;
  UpdateLiveClassSelectedClassLevelError(
      {required this.selectedClassLevelError});
}

// classtype action
class UpdateLiveClassSelectedCourseType extends ScheduleLiveclassAction {
  String? selectedCourseType;
  UpdateLiveClassSelectedCourseType({required this.selectedCourseType});
}

class UpdateLiveClassSelectedCourseTypeError extends ScheduleLiveclassAction {
  String? selectedCourseTypeError;
  UpdateLiveClassSelectedCourseTypeError(
      {required this.selectedCourseTypeError});
}

// lecture no action
class UpdateLiveClassLectureNo extends ScheduleLiveclassAction {
  String? lectureNo;
  UpdateLiveClassLectureNo({required this.lectureNo});
}

// agenda action
class UpdateLiveClassAgenda extends ScheduleLiveclassAction {
  String? agenda;
  UpdateLiveClassAgenda({required this.agenda});
}

class UpdateLiveClassAgendaError extends ScheduleLiveclassAction {
  String? agendaError;
  UpdateLiveClassAgendaError({required this.agendaError});
}

// description action
class UpdateLiveClassDescription extends ScheduleLiveclassAction {
  String? description;
  UpdateLiveClassDescription({required this.description});
}

class UpdateLiveClassDescriptionError extends ScheduleLiveclassAction {
  String descriptionError;
  UpdateLiveClassDescriptionError({required this.descriptionError});
}

class UpdateLiveClassPickedFiles extends ScheduleLiveclassAction {
  List<PlatformFile> pickedFiles;
  UpdateLiveClassPickedFiles({required this.pickedFiles});
}

class UpdateLiveClassPickedFilesName extends ScheduleLiveclassAction {
  List<String> pickedFilesName;
  UpdateLiveClassPickedFilesName({required this.pickedFilesName});
}

class UpdateLiveClassIsStudentMuted extends ScheduleLiveclassAction {
  bool? isStudentMuted;
  UpdateLiveClassIsStudentMuted({required this.isStudentMuted});
}

class RemoveLiveClassFile extends ScheduleLiveclassAction {
  String filename;
  RemoveLiveClassFile({required this.filename});
}

ScheduleLiveclassAppState _scheduleLiveclassStateReducer(
    ScheduleLiveclassAppState state, ScheduleLiveclassAction action) {
  switch (action) {
    case UpdateLiveClassSelectedSubject():
      return state.copyWith(
          selectedSubject: action.selectedSubject, selectedSubjectError: '');
    case UpdateLiveClassSelectedSubjectError():
      return state.copyWith(selectedSubjectError: action.selectedSubjectError);
    case UpdateAllTopics():
      return state.copyWith(allTopics: action.allTopics);
    case UpdateSelectedTopic():
      return state.copyWith(
          selectedTopic: action.selectedTopic, selectedTopicError: '');
    case UpdateSelectedTopicError():
      return state.copyWith(selectedTopicError: action.selectedTopicsError);
    case UpdateLiveClassSelectedDate():
      return state.copyWith(
          selectedDate: action.selectedDate, selectedDateError: '');
    case UpdateLiveClassSelectedDateError():
      return state.copyWith(selectedDateError: action.selectedDateError);
    case UpdateLiveClassSelectedStartTime():
      return state.copyWith(
          selectedStartTime: action.selectedStartTime,
          selectedStartTimeError: '');
    case UpdateLiveClassSelectedStartTimeError():
      return state.copyWith(
          selectedStartTimeError: action.selectedStartTimeError);
    case UpdateLiveClassSelectedEndTime():
      return state.copyWith(
          selectedEndTime: action.selectedEndTime, selectedEndTimeError: '');
    case UpdateLiveClassSelectedEndTimeError():
      return state.copyWith(selectedEndTimeError: action.selectedEndTimeError);
    case UpdateLiveClassSelectedChapter():
      return state.copyWith(
          selectedChapter: action.selectedChapter, selectedChapterError: '');
    case UpdateLiveClassSelectedChapterError():
      return state.copyWith(selectedChapterError: action.selectedChapterError);
    case UpdateLiveClassSelectedClassLevel():
      return state.copyWith(
          selectedClassLevel: action.selectedClassLevel,
          selectedClassLevelError: '');
    case UpdateLiveClassSelectedClassLevelError():
      return state.copyWith(
          selectedClassLevelError: action.selectedClassLevelError);
    case UpdateLiveClassSelectedCourseType():
      return state.copyWith(
          selectedCourseType: action.selectedCourseType,
          selectedCourseTypeError: '');
    case UpdateLiveClassSelectedCourseTypeError():
      return state.copyWith(
          selectedCourseTypeError: action.selectedCourseTypeError);
    case UpdateLiveClassLectureNo():
      return state.copyWith(lectureNo: action.lectureNo);
    case UpdateLiveClassAgenda():
      return state.copyWith(agenda: action.agenda, agendaError: '');
    case UpdateLiveClassAgendaError():
      return state.copyWith(agendaError: action.agendaError);
    case UpdateLiveClassDescription():
      return state.copyWith(
          description: action.description, descriptionError: '');
    case UpdateLiveClassDescriptionError():
      return state.copyWith(descriptionError: action.descriptionError);
    case UpdateLiveClassPickedFiles():
      return state.copyWith(pickedFiles: action.pickedFiles);
    case UpdateLiveClassPickedFilesName():
      return state.copyWith(pickedFilesName: action.pickedFilesName);
    case UpdateLiveClassIsStudentMuted():
      return state.copyWith(isStudentMuted: action.isStudentMuted);
    case RemoveLiveClassFile():
      return state.copyWith(
        pickedFilesName: state.pickedFilesName
            .where((name) => name != action.filename)
            .toList(),
        pickedFiles: state.pickedFiles
            .where((file) => file.name != action.filename)
            .toList(),
      );
  }
}

ScheduleLiveclassAppState scheduleLiveclassStateReducer(
    ScheduleLiveclassAppState state, dynamic action) {
  var upState = _scheduleLiveclassStateReducer(state, action);
  return upState;
}

ThunkAction<ScheduleLiveclassAppState> pickFilesforliveclass(
    BuildContext context) {
  return (Store<ScheduleLiveclassAppState> store) async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        allowMultiple: true,
        type: FileType.custom,
        allowedExtensions: ['pdf'],
      );

      if (result != null) {
        List<PlatformFile> pickedFiles = result.files;
        List<String> pickedFilesName =
            pickedFiles.map((item) => item.name).toList();
        store.dispatch(UpdateLiveClassPickedFiles(pickedFiles: pickedFiles));
        store.dispatch(
            UpdateLiveClassPickedFilesName(pickedFilesName: pickedFilesName));
      } else {
        print('User canceled the picker');
      }
    } catch (e) {
      print('Error picking file: $e');
    }
  };
}

ThunkAction<ScheduleLiveclassAppState> getLectureNumber(BuildContext context) {
  return (Store<ScheduleLiveclassAppState> store) async {
    try {
      if (store.state.selectedClassLevel != '' &&
          store.state.selectedCourseType != '' &&
          store.state.selectedSubject != '') {
        store.dispatch(getLectureNumberAPI(context));
      }
    } catch (error) {
      print("ERROR");
    }
  };
}

ThunkAction<ScheduleLiveclassAppState> getLectureNumberAPI(
    BuildContext context) {
  return (Store<ScheduleLiveclassAppState> store) async {
    try {
      final GetLectureNoRequestModel lectureRequestData =
          GetLectureNoRequestModel(
              classLevel: store.state.selectedClassLevel ?? '',
              classType: classType
                  .firstWhere(
                      (item) => item.label == store.state.selectedCourseType)
                  .value,
              isSoloClass: false,
              subjectName: store.state.selectedSubject ?? '');
      String userToken = await getUserToken();
      final remoteDataSource = RemoteDataSource();
      final allTopics = await remoteDataSource.getLectureNumber(
          lectureRequestData, userToken);

      if (allTopics.response.statusCode == 200) {
        store.dispatch(UpdateLiveClassLectureNo(
            lectureNo: allTopics.data.data.toString()));
      } else {
        store.dispatch(UpdateLiveClassLectureNo(lectureNo: "0"));
      }
    } catch (error) {
      store.dispatch(UpdateLiveClassLectureNo(lectureNo: "0"));
    }
  };
}

ThunkAction<ScheduleLiveclassAppState> showTopicsforLiveClassByChapter(
    BuildContext context, String? newValue) {
  return (Store<ScheduleLiveclassAppState> store) async {
    try {
      store.dispatch(UpdateSelectedTopic(selectedTopic: ''));
      store.dispatch(UpdateLiveClassSelectedChapter(selectedChapter: newValue));
      var chapterId =
          chapter.firstWhere((item) => item.label == newValue).value;

      final remoteDataSource = RemoteDataSource();
      final allTopics = await remoteDataSource.getAllTopicsByChapter(
          AllTopicsForChapterRequestModel(
              secret_key: "U5Ga0Z1aaNlYHp0MjdEdXJ1aKVVVB1TP",
              chapter_id: chapterId));

      if (allTopics.response.statusCode == 201 &&
          allTopics.data.status == true) {
        final List<ChapterTopicModel> allTopicsForSubject = allTopics
            .data.physicsCourseTopicsResponseModelResult
            .map((it) => ChapterTopicModel(value: it.id, label: it.name))
            .toList();

        store.dispatch(UpdateAllTopics(allTopics: allTopicsForSubject));
      } else {
        store.dispatch(UpdateAllTopics(allTopics: []));
      }
    } catch (error) {
      store.dispatch(UpdateAllTopics(allTopics: []));
    }
  };
}

ThunkAction<ScheduleLiveclassAppState> handleCreateLiveClass(
    BuildContext context) {
  return (Store<ScheduleLiveclassAppState> store) async {
    List<MultipartFile> files = [];

    if (store.state.selectedSubject == null ||
        store.state.selectedSubject!.isEmpty) {
      store.dispatch(UpdateLiveClassSelectedSubjectError(
          selectedSubjectError: 'Please select a subject'));
      return;
    }
    if (store.state.selectedClassLevel == null ||
        store.state.selectedClassLevel!.isEmpty) {
      store.dispatch(UpdateLiveClassSelectedClassLevelError(
          selectedClassLevelError: 'Please select a classlevel'));
      return;
    }
    if (store.state.selectedCourseType == null ||
        store.state.selectedCourseType!.isEmpty) {
      store.dispatch(UpdateLiveClassSelectedCourseTypeError(
          selectedCourseTypeError: 'Please select a classtype'));
      return;
    }
    if (store.state.selectedDate == null || store.state.selectedDate!.isEmpty) {
      store.dispatch(UpdateLiveClassSelectedDateError(
          selectedDateError: 'Please select a date'));
      return;
    }
    if (store.state.selectedStartTime == null ||
        store.state.selectedStartTime!.isEmpty) {
      store.dispatch(UpdateLiveClassSelectedStartTimeError(
          selectedStartTimeError: 'Please select a start time'));
      return;
    }
    if (store.state.selectedEndTime == null ||
        store.state.selectedEndTime!.isEmpty) {
      store.dispatch(UpdateLiveClassSelectedEndTimeError(
          selectedEndTimeError: 'Please select a end time'));
      return;
    }
    if (store.state.selectedChapter == null ||
        store.state.selectedChapter!.isEmpty) {
      store.dispatch(UpdateLiveClassSelectedChapterError(
          selectedChapterError: 'Please select a chapter'));
      return;
    }
    if (store.state.selectedTopic == null ||
        store.state.selectedTopic!.isEmpty) {
      store.dispatch(UpdateSelectedTopicError(
          selectedTopicsError: 'Please select a topic'));
      return;
    }
    if (store.state.agenda == null || store.state.agenda!.isEmpty) {
      store.dispatch(
          UpdateLiveClassAgendaError(agendaError: 'Please enter an agenda'));
      return;
    }
    if (store.state.description == null || store.state.description!.isEmpty) {
      store.dispatch(UpdateLiveClassDescriptionError(
          descriptionError: 'Please enter an description'));
      return;
    }

    for (PlatformFile file in store.state.pickedFiles) {
      if (kIsWeb || MediaQuery.of(context).size.width >= 600) {
        files.add(MultipartFile.fromBytes(file.bytes!, filename: file.name));
      } else {
        files
            .add(await MultipartFile.fromFile(file.path!, filename: file.name));
      }
    }
    Map<String, dynamic> jsonSubjectObject = {
      'value': subjectList
          .firstWhere((item) => item.label == store.state.selectedSubject)
          .value,
      'label': store.state.selectedSubject,
    };

    Map<String, dynamic> jsonTopicObject = {
      'value': topicList
          .firstWhere((item) => item.label == store.state.selectedTopic)
          .value,
      'label': store.state.selectedTopic,
    };

    Map<String, dynamic> jsonChapterObject = {
      'value': chapter
          .firstWhere((item) => item.label == store.state.selectedChapter)
          .value,
      'label': store.state.selectedChapter,
    };

    FormData formData = FormData.fromMap({
      'classType': classType
          .firstWhere((item) => item.label == store.state.selectedCourseType)
          .value,
      'topic': jsonEncode(jsonTopicObject),
      'chapter': jsonEncode(jsonChapterObject),
      'subject': jsonEncode(jsonSubjectObject),
      'classLevel': store.state.selectedClassLevel ?? '',
      'scheduledDate': store.state.selectedDate,
      'scheduledStartTime': store.state.selectedStartTime,
      'scheduledEndTime': store.state.selectedEndTime,
      'agenda': store.state.agenda,
      'lectureNo': store.state.lectureNo,
      'description': store.state.description,
      'muteAllStudents': store.state.isStudentMuted,
      'blockStudentsCamera': false,
      'files': files,
    });

    final dio = Dio();
    try {
      String userToken = await getUserToken();
      Response response = await dio.post(
        'https://dev.insp.1labventures.in/schedule-live-class/create',
        data: formData,
        options: Options(
          headers: {
            'Authorization': userToken, // Include the token in the header
            'Content-Type': 'multipart/form-data',
          },
        ),
      );

      if (response.statusCode == 201) {
        Navigator.of(context).pop();
        Fluttertoast.showToast(
            msg: 'Class Scheduled successfully',
            toastLength: Toast.LENGTH_LONG,
            backgroundColor: const Color(0xFF3C8DBC),
            timeInSecForIosWeb: 1,
            fontSize: 20.0);
      } else {
        Navigator.of(context).pop();
        Fluttertoast.showToast(
            msg: 'Failed to create class',
            toastLength: Toast.LENGTH_LONG,
            backgroundColor: const Color(0xFF3C8DBC),
            timeInSecForIosWeb: 1,
            fontSize: 20.0);
      }
    } catch (e) {
      Fluttertoast.showToast(
          msg: 'Some issue, please try again',
          toastLength: Toast.LENGTH_LONG,
          backgroundColor: const Color(0xFF3C8DBC),
          timeInSecForIosWeb: 1,
          fontSize: 20.0);
    }
  };
}
