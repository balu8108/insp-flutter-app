// This file is "main.dart"
import 'dart:convert';
import 'dart:io';

import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:insp/apiservices/models/login/device_login_request_model.dart';
import 'package:insp/main.dart';
import 'package:insp/redux/AppState.dart';
import 'package:insp/redux/userData/userdata_redux.dart';
import 'package:insp/utils/toaster.dart';
import 'package:toastification/toastification.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:insp/pages/home/home_screen.dart';
import 'package:insp/data/hardcoded/secret_key.dart';
import 'package:insp/utils/localstorage.dart';
import 'package:redux/redux.dart';
import 'package:redux_thunk/redux_thunk.dart';
import 'package:retrofit/dio.dart';
import 'package:uuid/uuid.dart';

import '../../apiservices/models/login/login_response_model.dart';
import '../../apiservices/remote_data_source.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'login_redux.freezed.dart';

@freezed
class LoginAppState with _$LoginAppState {
  const factory LoginAppState(
      [@Default('') String emailId,
      @Default('') String password,
      @Default(false) bool isPasswordVisible,
      @Default(false) bool isLoading]) = _LoginAppState;
}

sealed class LoginAction {}

class UpdateEmailId extends LoginAction {
  String emailId;

  UpdateEmailId({required this.emailId});
}

class UpdatePassword extends LoginAction {
  String password;

  UpdatePassword({required this.password});
}

class UpdatePasswordVisibleStatus extends LoginAction {
  bool isPasswordVisible;

  UpdatePasswordVisibleStatus({required this.isPasswordVisible});
}

class UpdateIsLoading extends LoginAction {
  bool isLoading;

  UpdateIsLoading({required this.isLoading});
}

LoginAppState loginStateReducer(LoginAppState state, dynamic action) {
  if (action is UpdateEmailId) {
    return state.copyWith(emailId: action.emailId);
  } else if (action is UpdatePassword) {
    return state.copyWith(password: action.password);
  } else if (action is UpdatePasswordVisibleStatus) {
    return state.copyWith(isPasswordVisible: action.isPasswordVisible);
  } else if (action is UpdateIsLoading) {
    return state.copyWith(isLoading: action.isLoading);
  }
  return state;
}

ThunkAction<AppState> handleLogin(BuildContext context) {
  return (Store<AppState> store) async {
    final loginState = store.state.loginState;

    if (loginState.password.isNotEmpty && loginState.emailId.isNotEmpty) {
      store.dispatch(UpdateIsLoading(isLoading: true));

      try {
        final loginRemoteDataSource = RemoteDataSource();
        Map<String, dynamic> deviceInfo = {};

        // Get manufacturer and other device info based on platform
        DeviceInfoPlugin deviceInfoPlugin = DeviceInfoPlugin();
        if (Platform.isWindows || Platform.isMacOS) {
          if (Platform.isWindows) {
            WindowsDeviceInfo windowsInfo = await deviceInfoPlugin.windowsInfo;
            deviceInfo['device_manufacturer'] =
                windowsInfo.computerName; // Usually computer name
            deviceInfo['device_id'] =
                windowsInfo.deviceId; // May be unique per device
          } else if (Platform.isMacOS) {
            MacOsDeviceInfo macInfo = await deviceInfoPlugin.macOsInfo;
            deviceInfo['device_manufacturer'] = 'Apple';
            deviceInfo['device_id'] = macInfo.systemGUID ?? 'Unknown';
          }
        } else if (Platform.isAndroid) {
          // Android-specific information
          AndroidDeviceInfo androidInfo = await deviceInfoPlugin.androidInfo;
          deviceInfo['device_manufacturer'] = androidInfo.manufacturer;
          deviceInfo['device_id'] =
              androidInfo.id; // Unique device ID for Android
        } else if (Platform.isIOS) {
          // iOS-specific information
          IosDeviceInfo iosInfo = await deviceInfoPlugin.iosInfo;
          deviceInfo['device_manufacturer'] = 'Apple';
          deviceInfo['device_id'] =
              iosInfo.identifierForVendor; // Unique device ID for iOS
        }
        final loginRequestModel = DeviceLoginRequestModel(
          secret_key: secretKey,
          email: loginState.emailId,
          password: loginState.password,
          device_os: Platform.operatingSystem,
          device_width: '136',
          device_height: '768',
          device_manufacturer: deviceInfo['device_manufacturer'],
          device_id: deviceInfo['device_id'],
          device_uuid: Uuid().v4(),
        );

        final HttpResponse<LoginResponseModel> result =
            await loginRemoteDataSource.deviceLogin(loginRequestModel);

        if (result.response.statusCode == 201) {
          if (result.data.status == true) {
            await storeData(
              'insp_user_profile',
              jsonEncode(result.data.loginResponseModelResult.toJson()),
            );

            store.dispatch(
                UpdateUserData(userData: result.data.loginResponseModelResult));

            pushAndRemoveUntilWithoutAnimation(
                context,
                MainScaffold(
                    content: HomeScreen(
                        userData: result.data.loginResponseModelResult)));

            showToast(context, "Logging you in !!", ToastificationType.success);
          } else if (result.data.status == false) {
            showToast(context, result.data.responseMessage,
                ToastificationType.warning);
          }
        } else {
          showToast(context, 'Invalid Credential', ToastificationType.warning);
        }
        store.dispatch(UpdateIsLoading(isLoading: false));
      } catch (error) {
        store.dispatch(UpdateIsLoading(isLoading: false));
        showToast(context, 'Error logging in', ToastificationType.error);
      }
    } else {
      showToast(context, "Please add credentials", ToastificationType.warning);
    }
  };
}
