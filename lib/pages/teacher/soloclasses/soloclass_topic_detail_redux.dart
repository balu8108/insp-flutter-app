// This file is "main.dart"
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:insp/apiservices/models/mycourses/physics_course_topics_request_model.dart';
import 'package:insp/apiservices/models/soloclasses/soloclass_topicwise_details_response_model.dart';
import 'package:insp/apiservices/remote_data_source.dart';
import 'package:insp/data/hardcoded/library_subjects.dart';
import 'package:insp/utils/extensions.dart';
import 'package:insp/utils/userDetail/getUserDetail.dart';
import 'package:insp/widget/card/model/insp_card_model.dart';
import 'package:redux_thunk/redux_thunk.dart';
import 'package:redux/redux.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'soloclass_topic_detail_redux.freezed.dart';

// optional: Since our Person class is serializable, we must add this line.
// But if Person was not serializable, we could skip it.
//part 'home_redux.g.dart';

@freezed
class SoloclassTopicDetailReduxAppState
    with _$SoloclassTopicDetailReduxAppState {
  const factory SoloclassTopicDetailReduxAppState({
    required INSPCardModel selectedTopic,
    @Default([]) List<INSPCardModel> allTopics,
    @Default(SoloclassTopicwiseDetailsResponseModel(
        totalLectures: 0,
        transformedData: TransformedModelData("", "", "", [], [])))
    SoloclassTopicwiseDetailsResponseModel soloclasstopicdetail,
  }) = _SoloclassTopicDetailReduxAppState;
}

SoloclassTopicDetailReduxAppState soloclassTopicDetailReducer(
    SoloclassTopicDetailReduxAppState state, dynamic action) {
  var upState = _soloclassTopicDetailReducer(state, action);
  if (kDebugMode) {}
  return upState;
}

sealed class SoloclassTopicDetailAction {}

SoloclassTopicDetailReduxAppState _soloclassTopicDetailReducer(
    SoloclassTopicDetailReduxAppState state,
    SoloclassTopicDetailAction action) {
  switch (action) {
    case UpdateSelectedTopic():
      return state.copyWith(selectedTopic: action.selectedTopics);
    case UpdateAllTopic():
      return state.copyWith(allTopics: action.allTopics);
    case UpdateAllTopicDetails():
      return state.copyWith(soloclasstopicdetail: action.soloclasstopicdetail);
  }
}

class UpdateSelectedTopic extends SoloclassTopicDetailAction {
  INSPCardModel selectedTopics;
  UpdateSelectedTopic({required this.selectedTopics});
}

class UpdateAllTopic extends SoloclassTopicDetailAction {
  List<INSPCardModel> allTopics;

  UpdateAllTopic({required this.allTopics});
}

// sction for topic details
class UpdateAllTopicDetails extends SoloclassTopicDetailAction {
  SoloclassTopicwiseDetailsResponseModel soloclasstopicdetail;

  UpdateAllTopicDetails({required this.soloclasstopicdetail});
}

ThunkAction<SoloclassTopicDetailReduxAppState> showAllTopics(
    BuildContext context) {
  return (Store<SoloclassTopicDetailReduxAppState> store) async {
    final remoteDataSource = RemoteDataSource();

    final allTopics = await remoteDataSource.getAllTopics(
        const PhysicsCourseTopicsRequestModel(
            secret_key: "U5Ga0Z1aaNlYHp0MjdEdXJ1aKVVVB1TP"));
    if (allTopics.response.statusCode == 201 && allTopics.data.status == true) {
      final allTopicsForSubject = allTopics
          .data.physicsCourseTopicsResponseModelResult
          .mapIndexed((index, it) => INSPCardModel(
              it.id,
              (it.name).capitalizeFirstLetter(),
              'Nitin Sachan',
              topicDescriptionConstants[int.parse(it.id ?? '1')] ?? ''))
          .toList();

      store.dispatch(initialFetchTopicDetail(context, allTopicsForSubject[0]));
      store.dispatch(UpdateAllTopic(allTopics: allTopicsForSubject));
    }
  };
}

ThunkAction<SoloclassTopicDetailReduxAppState> showSoloclassTopicwiseDetails(
    BuildContext context, INSPCardModel inspCardModel) {
  return (Store<SoloclassTopicDetailReduxAppState> store) async {
    store.dispatch(UpdateSelectedTopic(selectedTopics: inspCardModel));

    final remoteDataSource = RemoteDataSource();
    String userToken = getUserToken(context);
    try {
      final allTopics = await remoteDataSource.getSoloClassTopicWiseDetails(
          inspCardModel.id, userToken);
      if (allTopics.response.statusCode == 200) {
        final dataForTopic = allTopics.data;
        store.dispatch(
            UpdateAllTopicDetails(soloclasstopicdetail: dataForTopic));
      } else {
        const defaultValue = SoloclassTopicwiseDetailsResponseModel(
            totalLectures: 0,
            transformedData: TransformedModelData("", "", "", [], []));
        store.dispatch(
            UpdateAllTopicDetails(soloclasstopicdetail: defaultValue));
      }
    } catch (e) {
      const defaultValue = SoloclassTopicwiseDetailsResponseModel(
          totalLectures: 0,
          transformedData: TransformedModelData("", "", "", [], []));
      store.dispatch(UpdateAllTopicDetails(soloclasstopicdetail: defaultValue));
    }
  };
}

ThunkAction<SoloclassTopicDetailReduxAppState> initialFetchTopics(
    BuildContext context) {
  return (Store<SoloclassTopicDetailReduxAppState> store) async {
    store.dispatch(showAllTopics(context));
  };
}

ThunkAction<SoloclassTopicDetailReduxAppState> initialFetchTopicDetail(
    BuildContext context, INSPCardModel apiData) {
  return (Store<SoloclassTopicDetailReduxAppState> store) async {
    if (store.state.selectedTopic.id.isNotEmpty) {
      store.dispatch(
          showSoloclassTopicwiseDetails(context, store.state.selectedTopic));
    } else {
      store.dispatch(showSoloclassTopicwiseDetails(context, apiData));
    }
  };
}

ThunkAction<SoloclassTopicDetailReduxAppState>
    fetchTopicsDetailForSoloClassRoom(
        BuildContext context, INSPCardModel inspCardModel) {
  return (Store<SoloclassTopicDetailReduxAppState> store) async {
    store.dispatch(showSoloclassTopicwiseDetails(context, inspCardModel));
  };
}
