// This file is "main.dart"
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:inspflutterfrontend/apiservices/models/login/login_response_model.dart';
import 'package:inspflutterfrontend/apiservices/models/mycourses/all_lectures_for_course_response_model.dart';
import 'package:inspflutterfrontend/apiservices/models/tpstream/video_request_model.dart';
import 'package:inspflutterfrontend/apiservices/models/tpstream/video_response_model.dart';
import 'package:inspflutterfrontend/apiservices/models/upcomingclasses/lecture_detail_by_roomid_response_model.dart';
import 'package:inspflutterfrontend/apiservices/remote_data_source.dart';
import 'package:inspflutterfrontend/pages/common/livestream/mainscreen/liveclass.dart';
import 'package:inspflutterfrontend/pages/common/livestream/models/chat_message_model.dart';
import 'package:inspflutterfrontend/pages/common/livestream/models/increase_polltime_model.dart';
import 'package:inspflutterfrontend/pages/common/livestream/models/leaderboard_answer_model.dart';
import 'package:inspflutterfrontend/pages/common/livestream/models/leaderboard_model.dart';
import 'package:inspflutterfrontend/pages/common/livestream/models/peers_model.dart';
import 'package:inspflutterfrontend/pages/common/livestream/models/polldata_model.dart';
import 'package:inspflutterfrontend/pages/common/livestream/models/question_message_model.dart';
import 'package:inspflutterfrontend/pages/common/livestream/widget/chat/peers_widget_redux.dart';
import 'package:inspflutterfrontend/redux/AppState.dart';
import 'package:inspflutterfrontend/socket/mainsocket.dart';
import 'package:inspflutterfrontend/utils/userDetail/getUserDetail.dart';
import 'package:redux_thunk/redux_thunk.dart';
import 'package:redux/redux.dart';
import 'package:toastification/toastification.dart';
import 'package:uuid/uuid.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'chat_widget_redux.freezed.dart';

var uuid = Uuid();

@freezed
class ChatWidgetAppState with _$ChatWidgetAppState {
  const factory ChatWidgetAppState(
      {@Default(LecturesDetailResponseModelData())
      LecturesDetailResponseModelData previewData,
      @Default([]) List<LiveClassRoomFile> previewDataFiles,
      @Default([]) List<ChatMessageModel> chatMessages,
      @Default([]) List<LeaderboardModel> leaderBoard,
      @Default([]) List<LeaderBoardAnswerModel> leaderBoardAnswerPercentage,
      @Default([]) List<QuestionMessageModel> questionMessages,
      @Default(PollDataModel()) PollDataModel pollData,
      @Default(PollDataModel()) PollDataModel questionFromServer,
      @Default(VideoResponseModel()) VideoResponseModel videoResponse,
      @Default(IncreasePollTimeModel())
      IncreasePollTimeModel increasePollTimeModel}) = _ChatWidgetAppState;
}

class UpdatePreviewData extends ChatWidgetAction {
  LecturesDetailResponseModelData previewData;
  UpdatePreviewData({required this.previewData});
}

class UpdatePreviewDataFiles extends ChatWidgetAction {
  List<LiveClassRoomFile> previewDataFiles;
  UpdatePreviewDataFiles({required this.previewDataFiles});
}

class UpdateChatMessages extends ChatWidgetAction {
  List<ChatMessageModel> chatMessages;
  UpdateChatMessages({required this.chatMessages});
}

class UpdateLeaderBoard extends ChatWidgetAction {
  List<LeaderboardModel> leaderBoard;
  UpdateLeaderBoard({required this.leaderBoard});
}

class UpdateLeaderboardMessages extends ChatWidgetAction {
  List<LeaderBoardAnswerModel> leaderBoardAnswerPercentage;
  UpdateLeaderboardMessages({required this.leaderBoardAnswerPercentage});
}

class UpdateQuestionMessage extends ChatWidgetAction {
  List<QuestionMessageModel> questionMessages;
  UpdateQuestionMessage({required this.questionMessages});
}

class UpdatePollData extends ChatWidgetAction {
  PollDataModel pollData;
  UpdatePollData({required this.pollData});
}

class UpdateQuestionFromServer extends ChatWidgetAction {
  PollDataModel questionFromServer;
  UpdateQuestionFromServer({required this.questionFromServer});
}

class UpdateIncreasePollTimeModel extends ChatWidgetAction {
  IncreasePollTimeModel increasePollTimeModel;
  UpdateIncreasePollTimeModel({required this.increasePollTimeModel});
}

class UpdateVideoResponse extends ChatWidgetAction {
  VideoResponseModel videoResponse;
  UpdateVideoResponse({required this.videoResponse});
}

sealed class ChatWidgetAction {}

ChatWidgetAppState chatMessageStateReducer(
    ChatWidgetAppState state, dynamic action) {
  if (action is UpdatePreviewData) {
    return state.copyWith(previewData: action.previewData);
  } else if (action is UpdatePreviewDataFiles) {
    return state.copyWith(previewDataFiles: action.previewDataFiles);
  } else if (action is UpdateChatMessages) {
    return state.copyWith(chatMessages: action.chatMessages);
  } else if (action is UpdateLeaderBoard) {
    return state.copyWith(leaderBoard: action.leaderBoard);
  } else if (action is UpdateLeaderboardMessages) {
    return state.copyWith(
        leaderBoardAnswerPercentage: action.leaderBoardAnswerPercentage);
  } else if (action is UpdateQuestionMessage) {
    return state.copyWith(questionMessages: action.questionMessages);
  } else if (action is UpdatePollData) {
    return state.copyWith(pollData: action.pollData);
  } else if (action is UpdateQuestionFromServer) {
    return state.copyWith(questionFromServer: action.questionFromServer);
  } else if (action is UpdateIncreasePollTimeModel) {
    return state.copyWith(increasePollTimeModel: action.increasePollTimeModel);
  } else if (action is UpdateVideoResponse) {
    return state.copyWith(videoResponse: action.videoResponse);
  }
  return state;
}

ThunkAction<AppState> getPreviewClassData(BuildContext context, String roomId) {
  return (Store<AppState> store) async {
    try {
      LoginResponseModelResult userData = await getUserData();
      final remoteDataSource = RemoteDataSource();
      final previewData = await remoteDataSource.getRoomPreviewData(
          roomId, 'Token ${userData.token}');

      LecturesDetailResponseModelData previewFinalData =
          LecturesDetailResponseModelData.fromJson(
              previewData.response.data['data']);
      if (previewData.response.statusCode == 200) {
        store.dispatch(UpdatePreviewData(previewData: previewFinalData));
        store.dispatch(UpdatePreviewDataFiles(
            previewDataFiles: previewFinalData.liveClassRoomFiles));
        store.dispatch(initialSetup(context, roomId, userData.token));
      } else {
        toastification.show(
          context: context, // optional if you use ToastificationWrapper
          type: ToastificationType.warning,
          style: ToastificationStyle.fillColored,
          autoCloseDuration: const Duration(seconds: 3),
          title: const Text('Some issue, please try again'),
          alignment: Alignment.topRight,
        );
      }
    } catch (error) {
      toastification.show(
        context: context, // optional if you use ToastificationWrapper
        type: ToastificationType.error,
        style: ToastificationStyle.fillColored,
        autoCloseDuration: const Duration(seconds: 3),
        title: const Text('Some issue, please try again'),
        alignment: Alignment.topRight,
      );
    }
  };
}

ThunkAction<AppState> initialSetup(
    BuildContext context, String roomId, String token) {
  return (Store<AppState> store) async {
    initializeSocketConnections(store, roomId, token);
  };
}

ThunkAction<AppState> navigateToRoom(
    BuildContext context, String roomId, dynamic userProfile) {
  return (Store<AppState> store) async {
    await joinRoomHandler(store, roomId, userProfile, context);
  };
}

ThunkAction<AppState> cleanState() {
  return (Store<AppState> store) async {
    PollDataModel polldata = const PollDataModel(
        correctAnswers: [], noOfOptions: 0, questionId: '', type: '', time: 0);
    store.dispatch(UpdatePollData(pollData: polldata));
  };
}

ThunkAction<AppState> cleanQuestionState() {
  return (Store<AppState> store) async {
    PollDataModel questionFromServer = const PollDataModel(
        correctAnswers: [], noOfOptions: 0, questionId: '', type: '', time: 0);
    store.dispatch(
        UpdateQuestionFromServer(questionFromServer: questionFromServer));
  };
}

ThunkAction<AppState> addServerChatMessage(dynamic res) {
  return (Store<AppState> store) async {
    // Extracting 'msg' and 'peerDetails' from the response
    String msg = res['msg'];
    PeerDetail peerDetails = PeerDetail.fromJson(res['peerDetails']);

    // Assuming 'ChatMessageModel.fromJson' can handle the JSON structure
    ChatMessageModel newMessage = ChatMessageModel.fromJson(
        {'msg': msg, 'peerDetails': peerDetails.toJson()});

    // Get the current messages from the store
    List<ChatMessageModel> currentMessages =
        store.state.chatWidgetAppState.chatMessages;

    // Create the updated list of messages
    List<ChatMessageModel> chatMessages = [
      ...currentMessages.sublist(max(0, currentMessages.length - 50)),
      newMessage
    ];

    // Dispatch the action to update chat messages in the store
    store.dispatch(UpdateChatMessages(chatMessages: chatMessages));
  };
}

ThunkAction<AppState> addUserChatMessage(BuildContext context, String msg) {
  return (Store<AppState> store) async {
    // Extracting 'msg' and 'peerDetails' from the response
    PeerDetail peerDetails = PeerDetail(id: uuid.v4(), name: 'You');

    // Assuming 'ChatMessageModel.fromJson' can handle the JSON structure
    ChatMessageModel newMessage = ChatMessageModel.fromJson(
        {'msg': msg, 'peerDetails': peerDetails.toJson()});

    // Get the current messages from the store
    List<ChatMessageModel> currentMessages =
        store.state.chatWidgetAppState.chatMessages;

    // Create the updated list of messages
    List<ChatMessageModel> chatMessages = [
      ...currentMessages.sublist(max(0, currentMessages.length - 50)),
      newMessage
    ];

    // Dispatch the action to update chat messages in the store
    store.dispatch(UpdateChatMessages(chatMessages: chatMessages));
  };
}

ThunkAction<AppState> addServerQuestionMessage(dynamic res) {
  return (Store<AppState> store) async {
    // Extracting 'msg' and 'peerDetails' from the response
    String msg = res['msg'];
    PeerDetail peerDetails = PeerDetail.fromJson(res['peerDetails']);

    // Assuming 'ChatMessageModel.fromJson' can handle the JSON structure
    QuestionMessageModel newMessage = QuestionMessageModel.fromJson(
        {'questionMsg': msg, 'peerDetails': peerDetails.toJson()});

    // Get the current messages from the store
    List<QuestionMessageModel> currentMessages =
        store.state.chatWidgetAppState.questionMessages;

    // Create the updated list of messages
    List<QuestionMessageModel> questionMessages = [
      ...currentMessages.sublist(max(0, currentMessages.length - 50)),
      newMessage
    ];

    // Dispatch the action to update chat messages in the store
    store.dispatch(UpdateQuestionMessage(questionMessages: questionMessages));
  };
}

ThunkAction<AppState> addUserQuestionMessage(BuildContext context, String msg) {
  return (Store<AppState> store) async {
    // Extracting 'msg' and 'peerDetails' from the response
    PeerDetail peerDetails = PeerDetail(id: uuid.v4(), name: 'You');

    // Assuming 'ChatMessageModel.fromJson' can handle the JSON structure
    QuestionMessageModel newMessage = QuestionMessageModel.fromJson(
        {'questionMsg': msg, 'peerDetails': peerDetails.toJson()});

    // Get the current messages from the store
    List<QuestionMessageModel> currentQuestion =
        store.state.chatWidgetAppState.questionMessages;

    // Create the updated list of messages
    List<QuestionMessageModel> questionMessages = [
      ...currentQuestion.sublist(max(0, currentQuestion.length - 50)),
      newMessage
    ];

    // Dispatch the action to update chat messages in the store
    store.dispatch(UpdateQuestionMessage(questionMessages: questionMessages));
  };
}

ThunkAction<AppState> joinRoomResponseData(BuildContext context, dynamic res) {
  return (Store<AppState> store) async {
    if (res['selfDetails'] != null) {
      PeersDataModel peerdetail = PeersDataModel.fromJson(res['selfDetails']);

      List<PeersDataModel> allPeers = store.state.peersWidgetAppState.allPeers;

      // List<PeersDataModel> updatedLiveClassRoomPeer = [
      //   ...allPeers,
      //   peerdetail // Add all new files to the list
      // ];
      List<PeersDataModel> updatedLiveClassRoomPeer =
          List.generate(150, (index) => PeersDataModel(name: "Arto $index"));
      store.dispatch(UpdateAllPeers(allPeers: updatedLiveClassRoomPeer));
      store.dispatch(
          UpdateFilteredPeers(filteredPeers: updatedLiveClassRoomPeer));
    }
    if (res['leaderBoardData'] is List &&
        res['leaderBoardData'] != null &&
        res['leaderBoardData'].isNotEmpty) {
      // Ensure that each item in the list is a Map
      List<LeaderBoardAnswerModel> leaderBoardListAnswer =
          (res['leaderBoardData'] as List<dynamic>)
              .map((item) =>
                  LeaderBoardAnswerModel.fromJson(item as Map<String, dynamic>))
              .toList();

      store.dispatch(UpdateLeaderboardMessages(
          leaderBoardAnswerPercentage: leaderBoardListAnswer));
    }
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => LiveClassScreen()),
    );
  };
}

ThunkAction<AppState> addFileToPreviewData(dynamic res) {
  return (Store<AppState> store) async {
    // Check if 'files' exists and is a list
    if (res.containsKey('files') &&
        res['files'] != null &&
        res['files'] is List) {
      // Map each file in the list to a LiveClassRoomFile instance
      List<LiveClassRoomFile> fileDetailsList = (res['files'] as List)
          .map((file) => LiveClassRoomFile.fromJson(file))
          .toList();

      List<LiveClassRoomFile> previewDataFiles =
          store.state.chatWidgetAppState.previewDataFiles;

      // Create a new list that includes the existing files and the new file details.
      List<LiveClassRoomFile> updatedLiveClassRoomFiles = [
        ...previewDataFiles,
        ...fileDetailsList // Add all new files to the list
      ];

      // Dispatch the action to update chat messages in the store
      store.dispatch(
          UpdatePreviewDataFiles(previewDataFiles: updatedLiveClassRoomFiles));
    } else {
      print("Error: 'files' key not found, is null, or not a list.");
    }
  };
}

ThunkAction<AppState> getVideoUrlApi(BuildContext context) {
  return (Store<AppState> store) async {
    try {
      final remoteDataSource = RemoteDataSource();
      final chatState = store.state.chatWidgetAppState;

      // Validate the data before making the API call
      if (chatState.previewData.liveClassRoomRecordings.isNotEmpty) {
        final recording = chatState.previewData.liveClassRoomRecordings[0];
        final tpStreamId = recording.tpStreamId;
        if (tpStreamId.isNotEmpty) {
          final previewData = await remoteDataSource.getVideoPlayUrl(
              tpStreamId,
              const VideoRequestModel(),
              'Token cb5ee975c1a2a3cde54bbfe16e0ed5fc4662a8f20d1a9602a46c7229b42a5e52');

          VideoResponseModel videoResponseData =
              VideoResponseModel.fromJson(previewData.response.data);
          print(videoResponseData);
          // Dispatch the action to update chat messages in the store
          store.dispatch(UpdateVideoResponse(videoResponse: videoResponseData));
        } else {
          print("tpstream url null");
        }
      } else {
        print("tpreviewData null");
      }
    } catch (error) {
      toastification.show(
        context: context, // optional if you use ToastificationWrapper
        type: ToastificationType.error,
        style: ToastificationStyle.fillColored,
        autoCloseDuration: const Duration(seconds: 3),
        title: const Text('Some issue, please try again'),
        alignment: Alignment.topRight,
      );
    }
  };
}
