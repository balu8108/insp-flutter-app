// This file is "main.dart"
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:inspflutterfrontend/utils/class_constants.dart';
import 'package:inspflutterfrontend/widget/card/model/insp_card_model.dart';
import 'package:inspflutterfrontend/widget/card/model/lecture_card_model.dart';
import 'package:inspflutterfrontend/data/hardcoded/secret_key.dart';
import 'package:inspflutterfrontend/apiservices/remote_data_source.dart';
import 'package:intl/intl.dart';
import 'package:redux_thunk/redux_thunk.dart';
import 'package:redux/redux.dart';

// required: associates our `main.dart` with the code generated by Freezed
part 'topic_lecture_redux.freezed.dart';

@freezed
class TopicLectureAppState with _$TopicLectureAppState {
  const factory TopicLectureAppState({
    required INSPCardModel selectedTopic,
    @Default([]) List<INSPCardModel> allTopics,
    @Default([]) List<LectureCardModel> allTopicBasedLecture,
  }) = _TopicLectureAppState;
}

TopicLectureAppState topicLectureReducer(
    TopicLectureAppState state, dynamic action) {
  var upState = _topicLectureReducer(state, action);
  return upState;
}

sealed class TopicLectureAction {}

class UpdateSelectedTopic extends TopicLectureAction {
  INSPCardModel selectedTopic;
  UpdateSelectedTopic({required this.selectedTopic});
}

class UpdateAllTopic extends TopicLectureAction {
  List<LectureCardModel> allTopicBasedLecture;
  UpdateAllTopic({required this.allTopicBasedLecture});
}

TopicLectureAppState _topicLectureReducer(
    TopicLectureAppState state, TopicLectureAction action) {
  switch (action) {
    case UpdateSelectedTopic():
      return state.copyWith(selectedTopic: action.selectedTopic);
    case UpdateAllTopic():
      return state.copyWith(allTopicBasedLecture: action.allTopicBasedLecture);
  }
}

ThunkAction<TopicLectureAppState> showLecturesForTopic(
    BuildContext context, INSPCardModel inspCardModel) {
  return (Store<TopicLectureAppState> store) async {
    try {
      store.dispatch(UpdateSelectedTopic(selectedTopic: inspCardModel));

      final remoteDataSource = RemoteDataSource();
      final topicId = inspCardModel.id;
      final allTopics = await remoteDataSource.getAllLectureByTopic(
          topicId, "regular", 'Token $secretKeyToken');

      if (allTopics.response.statusCode == 200) {
        final List<LectureCardModel> allTopicBasedLecture = allTopics.data.data
            .map((it) => LectureCardModel(
                it.id.toString(),
                it.roomId,
                'Lecture ${it.liveClassRoomDetail.lectureNo}',
                '',
                it.liveClassRoomDetail.description,
                it.liveClassRoomDetail.topicName,
                DateFormat('dd/MM/yyyy')
                    .format(DateTime.parse(it.scheduledDate)),
                ClassLevel.getValueFromName(it.classLevel)))
            .toList();

        store.dispatch(
            UpdateAllTopic(allTopicBasedLecture: allTopicBasedLecture));
      } else {
        store.dispatch(UpdateAllTopic(allTopicBasedLecture: []));
      }
    } catch (error) {
      store.dispatch(UpdateAllTopic(allTopicBasedLecture: []));
    }
  };
}

ThunkAction<TopicLectureAppState> initialFetchLecture(BuildContext context) {
  return (Store<TopicLectureAppState> store) async {
    store.dispatch(showLecturesForTopic(context, store.state.selectedTopic));
  };
}
